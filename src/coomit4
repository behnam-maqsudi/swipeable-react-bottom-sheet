import { useEffect, useRef } from "react";
import { useDrag } from "@use-gesture/react";
import { a, useSpring } from "@react-spring/web";

export default function App({
  open,
  close,
  nonblocking = false,
  snapPoints,
  changeIndex,
  children,
}: any) {
  const content = useRef(null);
  const height = snapPoints[snapPoints.length - 1];
  const [{ y }, api] = useSpring(() => ({ y: height }));
  const display = y.to((py: number) => (py < height ? "block" : "none"));

  let childrenStyle = "hidden";

  const openBottomsheet = () => {
    changeIndex(0);
    api.start({ y: height - snapPoints[0], immediate: false });
  };

  const closeBottomsheet = () => api.start({ y: height, immediate: false });

  const bind = useDrag(
    ({ last, offset: [, oy], cancel }) => {
      if (oy < -10) cancel(); //
      const goal = height - oy;

      if (last) {
        if (oy > height - snapPoints[0]) close();
        else {
          const aa = content.current.children[0];

          console.log({ aa }, "children");

          const output = snapPoints.reduce((prev, curr) =>
            Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev
          );

          const findIndex = snapPoints.findIndex((item) => item === output);

          if (findIndex != -1) {
            if (findIndex + 1 === snapPoints.length) {
              content.current.style.backgroundColor = "red";
              content.current.style.overflow = "auto";
            } else {
              content.current.style.overflow = "hidden";
              content.current.style.backgroundColor = "greenyellow";
            }

            changeIndex(findIndex);

            api.start({
              y: height - output,
              immediate: false,
            });
          }
        }
      }

      // when the user keeps dragging, we just move the sheet according to
      // the cursor position
      else {
        const goal = height - oy;
        api.start({ y: oy, immediate: true });

        const output = snapPoints.reduce((prev, curr) =>
          Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev
        );

        const findIndex = snapPoints.findIndex((item) => item === output);

        // console.log(content.current.scrollTop, "parent");

        if (findIndex != -1) {
          if (findIndex + 1 === snapPoints.length) {
            content.current.style.backgroundColor = "red";
            content.current.style.overflow = "auto";
          } else {
            content.current.style.overflow = "hidden";
            content.current.style.backgroundColor = "greenyellow";
          }

          changeIndex(findIndex);
        }
      }
    },
    {
      from: () => [0, y.get()],
      filterTaps: true,
      bounds: { top: 0 },
      rubberband: true,
    }
  );

  useEffect(() => {
    if (open) openBottomsheet();
    else closeBottomsheet();
  }, [open]);

  // const _bind = useDrag(

  //   ({ last, offset: [, oy], cancel, locked, target, currentTarget }) => {
  //     if (oy < -10) cancel(); //

  //     console.log({ oy });
  //   },
  //   {
  //     from: () => [0, y.get()],
  //     filterTaps: true,
  //     bounds: { top: 0 },
  //     rubberband: true,
  //   }
  // );

  return (
    <a.div className="react-bottom-sheet" style={{ display }}>
      {!nonblocking && <a.div className="backdrop" onClick={close} />}
      <a.div
        className="sheet"
        {...bind()}
        style={{
          display,
          bottom: `calc(-100vh + ${height}px)`,
          y,
        }}
      >
        <div className="header" />
        <a.div
          style={{ overflow: childrenStyle }}
          ref={content}
          className={"root"}
        >
          {children}
        </a.div>
      </a.div>
    </a.div>
  );
}
